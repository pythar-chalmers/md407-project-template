# Include the Makefile.project to get the sources
include Makefile.project

# Device
# NOTE: Change these if they differ
DEV_PORT 		= /dev/ttyUSB0
GDB_SERVER_PORT = 1234

# Compiler & commands
CC 				= arm-none-eabi-gcc
LD 				= arm-none-eabi-ld
OBJCOPY 		= arm-none-eabi-objcopy
UPLOAD 			= python upload.py
GDB			 = arm-none-eabi-gdb

# Directories
INCLUDE_DIR 	= include

# Build destination directory
BUILD_DIR 		= build

# Includes
INCLUDES 		= $(wildcard $(INCLUDE_DIR)/**/*.h)

# Compiler & linker flags
CFLAGS 			= -mthumb -mcpu=cortex-m4 -mfpu=fpv4-sp-d16 -mfloat-abi=hard -O0 -Wall -Wextra -Wpedantic -std=c99 -g
CFLAGS 			+= -I /usr/arm-none-eabi/include
CFLAGS 		  	+= -ffreestanding -nostdlib
CFLAGS 			+= -L /usr/include/newlib/c++/9.2.1/arm-none-eabi/thumb/v6-m/nofp 
CFLAGS 			+= -L /usr/lib/arm-none-eabi/newlib/thumb/v6-m/nofp 
CFLAGS 			+= -L /usr/lib/gcc/arm-none-eabi/9.2.1/thumb/v6-m/nofp 

INCLUDE_DIRS 	= $(wildcard $(INCLUDE_DIR)/*)
INCLUDE_FLAGS 	= $(foreach dir,$(INCLUDE_DIRS),-I$(dir))
CFLAGS 		   += $(INCLUDE_FLAGS)

LDFLAGS		= -Tmd407-ram.x 
# LDFLAGS		+= -L /path/to/your/libraries

# Object files
OBJS 		= $(patsubst %.c,$(BUILD_DIR)/%.o,$(SOURCES))

# Output files
OUTPUT_BIN 		= $(BUILD_DIR)/output.bin
OUTPUT_S19 		= $(BUILD_DIR)/output.s19

# Build rules
all: $(OUTPUT_S19)

$(OUTPUT_S19): $(OUTPUT_BIN)
	@$(OBJCOPY) -I binary -O srec $< $@

$(OUTPUT_BIN): $(OBJS)
	@$(LD) $(LDFLAGS) -o $@ $^

$(BUILD_DIR)/%.o: %.c $(INCLUDES)
	@mkdir -p $(dir $@)
	@$(CC) $(CFLAGS) -c -o $@ $<

upload: $(OUTPUT_S19)
	$(UPLOAD) $(DEV_PORT) $(OUTPUT_S19)

s19: $(OUTPUT_S19) 

bin: $(OUTPUT_BIN)

gdb: $(OUTPUT_BIN)
 $(GDB) -ex "target extended-remote :$(GDB_SERVER_PORT)" -ex "load" -ex "layout split" -ex "file $(OUTPUT_BIN)"

clean:
	@rm -rf $(BUILD_DIR)

# Include dependencies (generated by GCC)
-include $(MAIN_OBJS:.o=.d)
-include $(DRIVER_OBJS:.o=.d)

.PHONY: all clean upload s19 bin
